---
description:
globs:
alwaysApply: false
---
// ───────────────────────────────────────────────────────────────
// 🛠️ 1. DEPENDENCIES — inject() AT THE TOP
// ───────────────────────────────────────────────────────────────
import { Component, ChangeDetectionStrategy, inject, signal, computed, DestroyRef } from '@angular/core';
import { toSignal, takeUntilDestroyed } from '@angular/core/rxjs-interop';
import { HttpClient } from '@angular/common/http';
import { DialogService } from 'primeng/dynamicdialog';

import type { Item } from '../openapi/models/item';
import type { UpdateProfileRequest } from '../openapi/models/update-request';
import { UserProfileService } from '../services/user-profile.service';
import { EditProfileComponent } from '../edit-profile/edit-profile.component';

// ───────────────────────────────────────────────────────────────
// 🔧 2. CONFIGURATION — STATIC VALUES & CONSTANTS
// ───────────────────────────────────────────────────────────────
const API_URL     = '/api/items';
const PAGE_SIZE   = 20;
const DEBOUNCE_MS = 300;

// ───────────────────────────────────────────────────────────────
// 🚦 3. STATE MANAGEMENT — PRIVATE writable, PUBLIC readonly
// ───────────────────────────────────────────────────────────────
@Component({
  selector: 'app-item-list',
  templateUrl: './item-list.component.html',
  styleUrls: ['./item-list.component.scss'],
  changeDetection: ChangeDetectionStrategy.OnPush,
  providers: [DialogService]
})
export class ItemListComponent {
  // ✨ Injected services
  private readonly http               = inject(HttpClient);
  private readonly destroyRef         = inject(DestroyRef);
  private readonly dialogService      = inject(DialogService);
  private readonly userProfileService = inject(UserProfileService);

  // 🚀 Private writable signals
  private readonly _items      = signal<Item[]>([]);
  private readonly _selectedId = signal<number | null>(null);
  private readonly _loading    = signal<boolean>(false);
  private readonly _error      = signal<string | null>(null);

  // 📖 Public readonly signals
  readonly items   = this._items.asReadonly();
  readonly loading = this._loading.asReadonly();
  readonly error   = this._error.asReadonly();

  // ───────────────────────────────────────────────────────────────
  // 🔍 4. COMPUTED STATE — DERIVE, DON’T DUPLICATE
  // ───────────────────────────────────────────────────────────────
  readonly selectedItem = computed(() =>
    this._items().find(i => i.id === this._selectedId()) ?? null
  );

  readonly hasItems = computed(() => this._items().length > 0);
  readonly hasError = computed(() => this._error() !== null);
  readonly isReady  = computed(() => !this._loading() && !this._error());

  /** Single “view model” for the template */
  readonly vm = computed(() => ({
    items:    this._items(),
    selected: this.selectedItem(),
    loading:  this._loading(),
    error:    this._error(),
    hasItems: this.hasItems(),
    isReady:  this.isReady()
  }));

  // ───────────────────────────────────────────────────────────────
  // ✨ 5. INITIALIZATION — NO EFFECTS, JUST DIRECT CALL
  // ───────────────────────────────────────────────────────────────
  constructor() {
    this.loadItems();
  }

  // ───────────────────────────────────────────────────────────────
  // 🎯 6. PUBLIC API — METHODS FOR UI & OUTSIDE
  // ───────────────────────────────────────────────────────────────
  select(id: number): void {
    this._selectedId.set(id);
  }

  clearSelection(): void {
    this._selectedId.set(null);
  }

  openEditProfile(): void {
    const profileSignal = toSignal(this.userProfileService.loadProfile(), { initialValue: null });
    const ref = this.dialogService.open(EditProfileComponent, {
      data: { profile: profileSignal() },
      header: 'Edit Profile',
      width: '400px'
    });

    ref.onClose.pipe(takeUntilDestroyed(this.destroyRef)).subscribe((update: UpdateProfileRequest) => {
      if (update) this.applyProfileUpdate(update);
    });
  }

  // ───────────────────────────────────────────────────────────────
  // 🔒 7. PRIVATE METHODS — INTERNAL LOGIC & HTTP CALLS
  // ───────────────────────────────────────────────────────────────
  private loadItems(): void {
    this._loading.set(true);
    this._error.set(null);

    this.http.get<Item[]>(API_URL, { params: { pageSize: PAGE_SIZE.toString() } })
      .pipe(takeUntilDestroyed(this.destroyRef))
      .subscribe({
        next: items => {
          this._items.set(items);
          this._loading.set(false);
          this.validateSelection();
        },
        error: err => {
          const msg = err.status === 404 ? 'No items found' : 'Failed to load items';
          this._error.set(msg);
          this._items.set([]);
          this._loading.set(false);
        }
      });
  }

  private applyProfileUpdate(update: UpdateProfileRequest): void {
    toSignal(this.userProfileService.updateProfile(update), { initialValue: null })();
    // no additional side-effects here—state update triggers re-render
  }

  private validateSelection(): void {
    if (this._selectedId() !== null && !this.selectedItem()) {
      this._selectedId.set(null);
    }
  }
}
